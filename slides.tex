\documentclass{beamer}

% Must be loaded first
\usepackage{tikz}

\usepackage[utf8]{inputenc}
\usepackage{textpos}

% Font configuration
\usepackage{fontspec}

\input{font.tex}

% Tikz for beautiful drawings
\usetikzlibrary{mindmap,backgrounds}
\usetikzlibrary{arrows.meta,arrows}
\usetikzlibrary{shapes.geometric}

% Minted configuration for source code highlighting
\usepackage{minted}
\setminted{highlightcolor=black!5, linenos}
\setminted{style=lovelace}

\usepackage[listings, minted]{tcolorbox}
\tcbset{left=6mm}

% Use the include theme
\usetheme{codecentric}

% Metadata
\title{Free All The Things}
\author{Markus Hauck}

% The presentation content
\begin{document}

\begin{frame}[noframenumbering,plain]
  \titlepage{}
\end{frame}

\section{Introduction}\label{sec:introduction}

\begin{frame}
\frametitle{Free All The Things}
\begin{itemize}
\item well known: free monads
\item maybe known: free applicatives
\item free monoids
\item free <you name it>
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Goal Of This Talk}
  \begin{itemize}
  \item how many of you wrote a Free X
  \item how many of you used Free\ldots
    \begin{itemize}
    \item Monad
    \item Applicative
    \item Functor
    \item Boolean Algebra
    \item other?
    \end{itemize}
  \item Goal: explain the technique behind ``Free X''
  \item Be able to apply the ``pattern'' yourself
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Road Ahead}
\end{frame}

\begin{frame}
  \frametitle{What Is Free}
  A free functor is left adjoint to a forgetful functor
  What's the problem?
\end{frame}

\begin{frame}
  \frametitle{What Is Free}
  \begin{itemize}
  \item a free X is the minimal thing that satisfies X's laws
  \item \textbf{nothing} else!

  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Why Free}
  \begin{itemize}
  \item having a Free X is good for a number of reasons
  \item use Free X as if it was X
  \item but the program is reified into some (data-)structure
  \item this structure can often be analyzed and optimized
  \item the killer: interpreters of the program can vary
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Scales of Power}
  \begin{itemize}
  \item the structures we will look at, are able to capture computations that have different power abilities
  \item monad: depend on previous values and branching
  \item applicative: fixed structure with arbitrary applicative effects in between
  \item functor: well\ldots
  \item monoid: limited power, but very flexible and composable
  \item surprise
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Free Vs Tagless}
  \begin{itemize}
  \item we will mostly look at the data structure version of Free X
  \item the alternative is to use finally tagless representations
  \end{itemize}
\end{frame}

\section{Freeing The Monad}\label{sec:free-monad}
\begin{frame}[fragile]
  \frametitle{Freeing The Monad}
  \begin{itemize}
  \item what are the operations?
  \end{itemize}
  \begin{center}
    \inputminted{scala}{snippets/monad-typeclass.code}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Freeing The Monad}
\begin{itemize}
  \item what are the laws?
\end{itemize}
    \begin{center}
\begin{minted}{scala}
// Left identity
pure(a).flatMap(f) === f(a)

// Right identity
fa.flatMap(pure) === fa

// Associativity
fa.flatMap(f).flatMap(g) ===
  fa.flatMap(a -> f(a).flatMap(g))
\end{minted}
    \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Freeing The Monad}
  \begin{itemize}
  \item todo: the minimal ``thing'' that has a \textit{Monad} instance
    \textbf{satisfies} the laws
  \item simple idea: capture as data
  \item btw: any minimal combination works!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Freeing The Monad}
    \begin{center}
\begin{minted}{scala}
trait Monad[F[_]] extends Applicative[F] {
  def pure[A](x: A): F[A]
  def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]
}
\end{minted}
\vspace{1cm}
\begin{minted}{scala}
sealed abstract class Free[F[_], A]

final case class Pure[F[_], A](a: A) extends Free[F, A]

final case class FlatMap[F[_], A, B](
  fa: Free[F, A], f: A => Free[F, B]) extends Free[F, B]
  \end{minted}
\end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Freeing The Monad}
    \begin{center}
\begin{minted}{scala}
implicit def freeMonad[F[_], A]: Monad[Free[F, A]] =
  new Monad[Free[F, A]] {
    def pure[A](x: A): Free[F, A] = Pure(x)

    def flatMap[A, B](fa: Free[F, A])(
      f: A => Free[F, B]): F[B] = FlatMap(fa, f)
  }
\end{minted}
\end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Interpreter}
  \begin{itemize}
  \item but what about the laws?!
  \item clearly we are violating all of them!
  \item we need one more thing: the interpreter
  \end{itemize}
  \begin{minted}{scala}
def runFree[F[_], M[_]:Monad, A](
  nat: FunctionK[F, M]): Free[F, A] => M[A] = ???
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Laws}
  \begin{itemize}
  \item together with the interpreter, we have to fulfill the laws
    \begin{minted}{scala}
runFree(nat)(pure(a).flatMap(f)) ===
  runFree(nat)(f(a))
    \end{minted}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{So What?}
  \begin{itemize}
  \item the laws tell us what ``rewriting'' is possible
  \item here: \textbf{flatMap} has to be associative, that means we can re-associate
  \item why? Let's look at what happens with normal \textbf{flatMap}s
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Freeing The Monad}
  \begin{itemize}
  \item that's it for the Monad
  \item what else?
  \end{itemize}
\end{frame}

\section{Freeing The Applicative}\label{sec:free-applicative}

\begin{frame}
  \frametitle{Freeing The Applicative}
  \begin{itemize}
  \item free monads are great, but also limited
  \item we can't analyze the programs
  \item how about a smaller gun?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Freeing The Applicative}
  \begin{itemize}
  \item we follow the same pattern
  \item look at typeclass operations
  \item create datastructure
  \item ``interpreter''
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Applicative Class}
  \begin{minted}{scala}
trait Applicative[F[_]] extends Functor[F] {
  def pure[A](x: A): F[A]
  def ap[A](fab: F[A => B], fa: F[A]): F[B]
}
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Freeing The Applicative}
  \begin{itemize}
  \item again the same pattern: we model it as an ADT
  \end{itemize}
  \begin{minted}{scala}
sealed abstract class FreeAp[F[_]]
final case class Pure[F[_], A](a: A) extends FreeAp[F, A]
final case class Ap[F[_], A, B](fab: FreeAp[F, A => B], fa: FreeAp[F, A]) extends FreeAp[F, B]
\end{minted}
\begin{itemize}
\item of course we also need the interpreter
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Less Power?!}
  \begin{itemize}
  \item why would we consider Applicative if it's less powerful?
  \item less is more: we can inspect the AST
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Freeing The Functor}
  \begin{itemize}
  \item we are well equipped by now
  \end{itemize}
  \begin{minted}{scala}
sealed abstract class FreeFun[F[_]]
final case class Fmap(f: A => B, fa: FreeFun[A]) extends FreeFun[B]
  \end{minted}
\end{frame}

\section{Freeing The Boolean Algebra}\label{sec:free-boolean-algebra}

\begin{frame}
  \frame{Boolean Algebras}
  \begin{itemize}
  \item seen: common fp type classes
  \item apply our knowledge to another example: boolean algebras
  \end{itemize}
\end{frame}

\section{Conclusion}\label{sec:conclusion}

\begin{frame}
  \begin{center}
    \huge
    Your conclusion here
  \end{center}
\end{frame}

\end{document}
